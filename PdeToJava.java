import org.antlr.v4.runtime.*;
import org.antlr.v4.runtime.tree.*;
import org.antlr.v4.runtime.misc.*;

import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.util.List;
import java.util.ArrayList;
import java.util.Date;
import java.text.SimpleDateFormat;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class PdeToJava 
{
	// Processing 3.0 starting with 3.0.0
	final static String version = "3.0.0";

	final static String DEFAULT_SKETCH_NAME = "Sketch";
	final static String[] DEFAULT_IMPORTS = new String[]{
				"java.util.HashMap",
				"java.util.ArrayList",
				"java.io.File",
				"java.io.BufferedReader",
				"java.io.PrintWriter",
				"java.io.InputStream",
				"java.io.OutputStream",
				"java.io.IOException",
				"processing.core.*",
				"processing.data.*",
				"processing.event.*",
				"processing.opengl.*"
			};

	public static class PdeToJavaListener 
	extends ProcessingBaseListener 
	{
		final String NL = "\n";
		String sketchName = DEFAULT_SKETCH_NAME;
		boolean hasMain = false;

		BufferedTokenStream tokens;
		TokenStreamRewriter rewriter;

		ArrayList<String> imports;

		PdeToJavaListener ( BufferedTokenStream tokens, String rawName )
		{
			this.tokens = tokens;
			rewriter = new TokenStreamRewriter(tokens);

			sketchName = rawName;

			imports = new ArrayList<String>();
			for ( String importDecl : DEFAULT_IMPORTS ) {
				imports.add( "import " + importDecl + ";" );
			}
		}

		// --------------------------------------------------- listener impl

		/**
		 *	Wrap the sketch code inside a class definition and
		 *	add all imports found to the top incl. the default ones
		 */
		public void exitProcessingSketch ( ProcessingParser.ProcessingSketchContext ctx )
		{
			rewriter.insertBefore( 0, NL + "public class " + sketchName + " extends PApplet {" + NL );
			
			StringBuffer buf = new StringBuffer();
			if ( !hasMain ) 
			{
				buf.append( NL );
				buf.append( "static public void main ( String[] passedArgs ) {" + NL );
				buf.append( "    String[] appletArgs = new String[] { " + NL );
				
				// if ( Preferences.getBoolean("export.application.fullscreen") ) 
				// {
    //     			out.print("\"" + PApplet.ARGS_FULL_SCREEN + "\", ");

				// 	String farbe = Preferences.get("run.present.bgcolor");
				// 	out.print("\"" + PApplet.ARGS_BGCOLOR + "=" + farbe + "\", ");

				// 	if (Preferences.getBoolean("export.application.stop")) 
				// 	{
    //         			farbe = Preferences.get("run.present.stop.color");
    //         			out.print("\"" + PApplet.ARGS_STOP_COLOR + "=" + farbe + "\", ");
    //       			} else {
    //         			out.print("\"" + PApplet.ARGS_HIDE_STOP + "\", ");
    //       			}
    //     		}

				buf.append( "        \"" + sketchName + "\"" + NL );
				buf.append( "    };" + NL );

				buf.append( "    if ( passedArgs != null ) {" + NL );
				buf.append( "        PApplet.main( concat(appletArgs, passedArgs) );" + NL );
				buf.append( "    } else {" + NL );
				buf.append( "        PApplet.main( appletArgs );" + NL );
				buf.append( "    }" + NL );

				buf.append( "}" + NL );
			}
			buf.append( NL + "}" + NL );

			rewriter.insertAfter( rewriter.getTokenStream().size(), buf.toString() );

			for ( String importDecl : imports ) {
				rewriter.insertBefore( 0, importDecl + NL );
			}

			rewriter.insertBefore( 
				0, 
				String.format(
					"/* autogenerated by Processing preprocessor v%s on %s */"+NL,
					version,
					new SimpleDateFormat("YYYY-MM-dd").format(new Date())
				)
			);
 		}

 		public void exitApiSizeFunction( ProcessingParser.ApiSizeFunctionContext ctx )
 		{
 			// this tree climbing could be avoided if grammar is 
 			// adjusted to force context of size()

			ParserRuleContext testCtx = 
				ctx.getParent() // apiFunction
					.getParent() // expression
					.getParent() // statementExpression
					.getParent() // statement
					.getParent() // blockStatement
					.getParent(); // block or staticProcessingSketch

			boolean isSizeInSetupOrGlobal = 
				testCtx instanceof ProcessingParser.StaticProcessingSketchContext;

			if ( !isSizeInSetupOrGlobal ) {
				testCtx =
					testCtx.getParent() // methodBody of setup()
						.getParent(); // methodDeclaration of setup()

				String methodName = testCtx.getChild(1).getText();
				testCtx = testCtx.getParent() // memberDeclaration
					.getParent() // classBodyDeclaration
					.getParent(); // activeProcessingSketch
				
				isSizeInSetupOrGlobal = 
					methodName.equals("setup") && 
					testCtx instanceof ProcessingParser.ActiveProcessingSketchContext;
			}

			if ( isSizeInSetupOrGlobal ) {
				System.out.println(String.format(
					"size-width: %s size-height: %s size-renderer: %s",
					ctx.getChild(2).getText(),
					ctx.getChild(4).getText(),
					ctx.getChildCount() > 6 ? ctx.getChild(6).getText() : "<no set>"
				));
			}
 		}

 		/**
 		 *	Store import declarations when found and remove from 
 		 *	"inside" the code as these are placed at the top of the file.
 		 */
		public void exitImportDeclaration ( ProcessingParser.ImportDeclarationContext ctx ) 
		{
			String importDecl = tokens.getText( ctx.start, ctx.stop );
			//System.out.println( importDecl );
			imports.add( importDecl );
			rewriter.delete( ctx.start, ctx.stop );
		}

		/**
		 *	Any floating point number that has not float / double suffix
		 *	will get a 'f' appended to make it float.
		 */
		public void exitDecimalfloatingPointLiteral ( ProcessingParser.DecimalfloatingPointLiteralContext ctx ) 
		{
			String cTxt = ctx.getText().toLowerCase();
			if ( !cTxt.endsWith("f") && !cTxt.endsWith("d") ) {
				rewriter.insertAfter( ctx.stop, "f" );
			}
		}

		/**
		 *	Wrap "static sketches" into a setup() method with 
		 *	noLoop() at the end.
		 */
		public void exitStaticProcessingSketch ( ProcessingParser.StaticProcessingSketchContext ctx )
		{
			rewriter.insertBefore( ctx.start, "public void setup() {" + NL );
			rewriter.insertAfter( ctx.stop, NL + "noLoop();" + NL + "}" + NL );
		}

		/**
		 *	Make any method "public" that has:
		 *	- no other access modifier
		 *	- return type "void"
		 *	- is either in the context of the sketch class
		 *	- or is in the context of a class definition that extends PApplet
		 */
		public void exitMethodDeclaration ( ProcessingParser.MethodDeclarationContext ctx ) 
		{
			ParserRuleContext memCtx = ctx.getParent();
			ParserRuleContext clsBdyDclCtx = memCtx.getParent();
			ParserRuleContext clsBdyCtx = clsBdyDclCtx.getParent();
			ParserRuleContext clsDclCtx = clsBdyCtx.getParent();

			boolean inSketchContext = 
				clsBdyCtx instanceof ProcessingParser.StaticProcessingSketchContext ||
				clsBdyCtx instanceof ProcessingParser.ActiveProcessingSketchContext;

			boolean inPAppletContext =
				inSketchContext || (
					clsDclCtx instanceof ProcessingParser.ClassDeclarationContext &&
					clsDclCtx.getChildCount() >= 4 && 
					clsDclCtx.getChild(2).getText().equals("extends") &&
					clsDclCtx.getChild(3).getText().endsWith("PApplet")
				);

			boolean voidType = 
				ctx.getChild(0).getText().equals("void");

			boolean hasModifier = 
				clsBdyDclCtx.getChild(0) != memCtx; // not the first, so no mod before

			if ( !hasModifier && inPAppletContext && voidType ) {
				rewriter.insertBefore( memCtx.start, "public " );
			}

			if ( inSketchContext && 
				 hasModifier && 
				 ctx.getChild(1).getText().equals("main") ) {
				hasMain = true;
			}
		}

		/**
		 *	Change any "value converters" with the name of a primitive type
		 *	to their proper names:
		 *	int() --> parseInt()
		 *	float() --> parseFloat()
		 *  ...
		 */
		public void exitFunctionWithPrimitiveTypeName ( ProcessingParser.FunctionWithPrimitiveTypeNameContext ctx ) 
		{
			String fn = ctx.getChild(0).getText();
			if ( !fn.equals("color") ) {
				fn = "parse" + fn.substring(0,1).toUpperCase() + fn.substring(1);
				rewriter.insertBefore( ctx.start, fn );
				rewriter.delete( ctx.start );
			}
		}

		/**
		 *	Fix "color type" to be "int".
		 */
		public void exitColorPrimitiveType ( ProcessingParser.ColorPrimitiveTypeContext ctx ) 
		{
			if ( ctx.getText().equals("color") ) 
			{
				rewriter.insertBefore( ctx.start, "int" );
				rewriter.delete( ctx.start, ctx.stop );
			}
		}

		/**
		 *	Fix hex color literal
		 */
		public void exitHexColorLiteral ( ProcessingParser.HexColorLiteralContext ctx )
		{
			rewriter.insertBefore( ctx.start, ctx.getText().toUpperCase().replace("#","0xFF") );
			rewriter.delete( ctx.start, ctx.stop );
		}
	}
	
	/**
	 *	It should:
	 *	- take single file and convert it
	 *	- take sketch folder, concat *.pde and convert result
	 *	- take directory, scan it, convert every sketch folder
	 */
    public static void main(String[] args) 
    throws Exception 
    {
        String inputFile = null;
        if ( args.length>0 ) inputFile = args[0];

        String pdeFileName = "ProcessingSketch";
        InputStream is = System.in;

        if ( inputFile!=null ) {
        	File f = new File(inputFile);
        	if ( f.exists() && f.isFile() && f.canRead() ) {
        		pdeFileName = f.getName();
        		if ( pdeFileName.lastIndexOf('.') > 0 )
        			pdeFileName = pdeFileName.substring(0,pdeFileName.lastIndexOf('.'));
            	is = new FileInputStream(inputFile);
        	}
        }

        if ( args.length > 1 ) {
        	pdeFileName = args[1];
        }

        ANTLRInputStream input = new ANTLRInputStream(is);
        ProcessingLexer lexer = new ProcessingLexer(input);
        CommonTokenStream tokens = new CommonTokenStream(lexer);
        ProcessingParser parser = new ProcessingParser(tokens);
        parser.setBuildParseTree(true);
        ParseTree tree = parser.processingSketch();
        ParseTreeWalker walker = new ParseTreeWalker();
        PdeToJavaListener converter = new PdeToJavaListener(tokens, pdeFileName);
        walker.walk(converter, tree);

        System.out.println( converter.rewriter.getText() );
    }

	/**
	 *	Take any input String and create a "good" Java class name from it.
	 */
	private static String cleanSketchName ( String rawName )
	{
		String newName = "";

		String[] parts = rawName.split("[^a-zA-Z0-9_]");
		for ( String s : parts ) {
			if ( s != null && !s.equals("") ) {
				newName += s.substring(0,1).toUpperCase();
				String sRest = s.substring(1);
				if ( sRest != null ) {
					newName += sRest;
				}
			}
		}

		newName = newName.replaceAll("^[0-9]+","");

		if ( newName.length() < 3 ) {
			newName = cleanSketchName( DEFAULT_SKETCH_NAME + "_" + newName + "_" + (new Date()).getTime() );
		}

		return newName;
	}
}